//SPDX-License-Identifier: Unlicense
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import "@openzeppelin/contracts/utils/Context.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "./verifier.sol";
import "hardhat/console.sol";
import "./mock/HeirToken.sol";

contract PecuniaLock is Context, IERC721Receiver {
    using Counters for Counters.Counter;
    //include enum for will state

    ///Minimum interval between payments after the will is matured
    uint32 public immutable minTimeIntBetweenPayments;

    // Observed gas is 92k + 8k buffer
    uint256 private constant MIN_GAS_FOR_TRANSFER = 100_000;

    uint256 public gb;
    uint256 public gb1;
    uint256 public gb2;

    Verifier verifier;

    HeirToken public heirToken;

    event Register(bytes32 indexed boxhash, address indexed owner);

    event RechargeMatic(
        address indexed sender,
        address indexed heirAddress,
        uint256 amount
    );

    event RechargeNft(
        address indexed sender,
        address indexed heirAddress,
        address nftAddress
    );

    event WithdrawSigned(
        address indexed owner,
        address indexed to,
        uint256 amount
    );

    event BoxCanceled(address indexed owner);

    event FundsAdded(uint256 amountAdded, uint256 newBalance, address sender);

    event FundsTransferred(uint256 amount, address heir);

    bytes32[] private boxHashes;

    ///Prevent Re-Entracy Attack
    bool private locked;

    struct SafeBox {
        bytes32 boxhash;
        uint64 numberOfPayments; //Number of payment we need to do to heir
        uint64 paymentsDoneToHeir; //counter for number of payments done to heir, init=0
        address user;
        address nftAddress;
        uint256 heirToInterval;
        uint256 timeAtWhichPaymentStarts; //this is the time at whcih the payment will start
        uint256 totalDeposit;
        uint256 lastPaymentTime; //time stamp to remember last payment time, next payment will be lastPaymentTime+timeIntBetweenPayments
        uint256 timeIntBetweenPayments; //time interval between payments we need to maintain for batch payments
        address[] addresss;
        mapping(address => uint256) heirToBalance;
        mapping(address => uint256) ratePerHeir; // amount of crypto transffered per interva;
        mapping(address => uint256) heirToTokenid;
        mapping(address => bool) withdrawSigned;
        mapping(address => uint256[]) heirToNfts;
        mapping(address => bool) isActive;
    }

    mapping(bytes32 => SafeBox) public boxhash2safebox;

    mapping(address => bytes32) public user2boxhash;

    mapping(uint256 => bool) public usedProof;

    mapping(uint256 => bool) public isHeirTokenValid;

    constructor() {
        verifier = new Verifier();
        heirToken = new HeirToken();
        heirToken.mint(address(this), "Genesis Token");
        minTimeIntBetweenPayments = 1 seconds;
        gb = 0;
        gb1 = 0;
        gb2 = 0;
    }

    // function balanceOf(address user, address[] memory tokenAddrs) public view returns(uint[] memory bals) {
    //     bytes32 boxhash = user2boxhash[user];
    //     SafeBox storage box = boxhash2safebox[boxhash];
    //     bals = new uint[](tokenAddrs.length);
    //     for (uint i=0; i<tokenAddrs.length; i++) {
    //         address tokenAddr = tokenAddrs[i];
    //         bals[i] = box.balance[tokenAddr];
    //     }
    // }

    /**
     * @notice Register the user
     * @param boxhash the hash of box
     * @param proof zero-knowledge proof generated by the hash of password
     * @param pswHash password hash
     * @param allHash hash of amount and password
     * @param interval time after which will amount is transffered
     * @param timeIntBetweenPayments time interval between the payments done to heir
     * @param numberOfPayments number of payments done toheir
     */
    function register(
        bytes32 boxhash,
        uint256[8] memory proof,
        uint256 pswHash,
        uint256 allHash,
        uint256 interval,
        uint256 timeIntBetweenPayments,
        uint64 numberOfPayments
    ) public {
        SafeBox storage box = boxhash2safebox[boxhash];

        require(
            user2boxhash[_msgSender()] == bytes32(0),
            "PecuniaLock::register: one user one safebox"
        );
        require(
            box.boxhash == bytes32(0),
            "PecuniaLock::register: boxhash has been registered"
        );
        require(
            keccak256(abi.encodePacked(pswHash, _msgSender())) == boxhash,
            "PecuniaLock::register: boxhash error"
        );
        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                [pswHash, 0, allHash]
            ),
            "PecuniaLock::register: verifyProof fail"
        );
        require(interval > 0, "PecuniaLock::register: interval cannot be zero");

        require(
            numberOfPayments >= 1,
            "PecuniaLock::register: Number of payments should more than zero"
        );

        require(
            timeIntBetweenPayments >= minTimeIntBetweenPayments,
            "PecuniaLock::register: Interval between payments should be greater than min interval"
        );

        box.boxhash = boxhash;
        box.user = _msgSender();
        box.heirToInterval = interval;
        box.timeAtWhichPaymentStarts = block.timestamp;
        box.numberOfPayments = numberOfPayments;
        box.timeIntBetweenPayments = timeIntBetweenPayments;

        user2boxhash[box.user] = boxhash;
        boxHashes.push(boxhash);
        emit Register(boxhash, box.user);
    }

    /**
     * @notice assign funds and nfts to heir using address of owner
     * @param boxOwner address of box owner
     * @param heirAddr address of the heir
     * @param nftAddr address of the nft
     * @param nftTokenIds token ids
     * @return tokenId of the HEIR NFT
     */
    function rechargeWithAddress(
        address boxOwner,
        address heirAddr,
        address nftAddr,
        uint256[] memory nftTokenIds
    ) external payable returns (uint256 tokenId) {
        require(
            msg.sender == boxOwner,
            "PecuniaLock::rechargeWithAddress: only owner can assign funds to heirs"
        );
        require(
            heirAddr != address(0),
            "PecuniaLock::rechargeWithAddress: Heir cannot be 0 address"
        );
        require(
            boxOwner != heirAddr,
            "PecuniaLock::rechargeWithAddress: Owner cannot be heir"
        );
        uint256 amount = msg.value;
        tokenId = _rechargeWithAddress(
            boxOwner,
            heirAddr,
            amount,
            nftAddr,
            nftTokenIds
        );
        return tokenId;
    }

    /**
     * @notice internal funciton to assign funds and nfts to heir using address of owner
     * @param boxOwner address of box owner
     * @param heirAddr address of the heir
     * @param nftAddr address of the nft
     * @param nftTokenIds token ids
     * @return tokenId of the HEIR NFT
     */
    function _rechargeWithAddress(
        address boxOwner,
        address heirAddr,
        uint256 amount,
        address nftAddr,
        uint256[] memory nftTokenIds
    ) internal returns (uint256 tokenId) {
        bytes32 boxhash = user2boxhash[boxOwner];
        require(
            boxhash != bytes32(0),
            "PecuniaLock::rechargeWithAddress: safebox not register yet"
        );

        SafeBox storage box = boxhash2safebox[boxhash];
        require(
            box.isActive[heirAddr] == false,
            "PecuniaLock::rechargeWithAddress: Amount already assigned to heir"
        );
        require(
            amount > 0 || (nftAddr != address(0) && nftTokenIds.length >= 0),
            "PecuniaLock::rechargeWithAddress: Both amount and NFT cannot be empty"
        );

        require(
            amount % box.numberOfPayments == 0,
            "PecuniaLock::rechargeWithAddress: amount should be divisible by number of payments"
        );

        if (amount > 0) {
            _rechargeOfMatic(boxOwner, boxhash, heirAddr, amount);
            console.log("amount deposited=", amount);
        }
        if (nftAddr != address(0) && nftTokenIds.length >= 0) {
            if (box.nftAddress == address(0)) {
                box.nftAddress = nftAddr;
            }
            _rechargeOfNft(boxOwner, boxhash, heirAddr, nftAddr, nftTokenIds);
            console.log("NFTs deposited");
        }
        box.isActive[heirAddr] = true;
        // TODO: SOULBOUND NFTS
        tokenId = heirToken.mint(heirAddr);
        
        heirToken.updateAmountAndURI(tokenId, amount);

        box.heirToTokenid[heirAddr] = tokenId;
        box.addresss.push(heirAddr);

        return tokenId;
    }

    /**
     * @notice assign funds to heir using boxhash
     * @param boxOwner address of box owner
     * @param boxhash the hash of box
     * @param heirAddr address of the heir
     * @param amount amount of matic assigned to heir
     */
    function _rechargeOfMatic(
        address boxOwner,
        bytes32 boxhash,
        address heirAddr,
        uint256 amount
    ) internal {
        SafeBox storage box = boxhash2safebox[boxhash];
        box.heirToBalance[heirAddr] += amount;
        box.totalDeposit += amount;
        box.ratePerHeir[heirAddr] = amount / box.numberOfPayments;
        emit RechargeMatic(boxOwner, heirAddr, amount);
    }

    /**
     * @notice assign nfts to heir using boxhash
     * @param boxOwner address of box owner
     * @param boxhash the hash of box
     * @param heirAddr address of the heir
     * @param nftAddr address of nft
     * @param nftTokenIds token ids
     */
    function _rechargeOfNft(
        address boxOwner,
        bytes32 boxhash,
        address heirAddr,
        address nftAddr,
        uint256[] memory nftTokenIds
    ) internal {
        SafeBox storage box = boxhash2safebox[boxhash];

        for (uint256 i = 0; i < nftTokenIds.length; i++) {
            require(
                IERC721(nftAddr).getApproved(nftTokenIds[i]) == address(this),
                "PecuniaLock::_rechargeOfNft: NFT approval not set"
            );
            IERC721(nftAddr).safeTransferFrom(
                boxOwner,
                address(this),
                nftTokenIds[i]
            );
            box.heirToNfts[heirAddr].push(nftTokenIds[i]);
        }
        emit RechargeNft(boxOwner, heirAddr, nftAddr);
    }

    /**
     * @notice heir needs to sign the will before the chainlink keepers send amount to his/her address
     * @param proof zero-knowledge proof genereated using password
     * @param pswHash hash of the password
     * @param allHash hash of the password and amount
     * @param boxOwner address of box owner
     */
    function withdrawSignature(
        uint256[8] memory proof,
        uint256 pswHash,
        uint256 allHash,
        address boxOwner
    ) public {
        address heir = msg.sender;
        require(
            heir != boxOwner,
            "PecuniaLock::withdrawSignature: Owner cannot withdraw amount"
        );
        require(
            !usedProof[proof[0]],
            "PecuniaLock::withdrawSignature: proof used"
        );

        bytes32 boxhash = user2boxhash[boxOwner];
        require(
            keccak256(abi.encodePacked(pswHash, boxOwner)) == boxhash,
            "PecuniaLock::withdrawSignature: pswHash error"
        );

        SafeBox storage box = boxhash2safebox[boxhash];
        require(
            box.boxhash != bytes32(0),
            "PecuniaLock::withdrawSignature: safebox not register yet"
        );

        require(
            box.heirToTokenid[heir] > 0,
            "PecuniaLock::withdrawSignature: Heir not valid"
        );

        require(
            box.isActive[heir],
            "PecuniaLock::withdrawSignature: Heir has already taken amount or will is canceled"
        );

        uint256 amount = box.heirToBalance[heir];
        console.log("amount withdrawn", amount);

        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                [pswHash, amount, allHash]
            ),
            "PecuniaLock::withdraw: verifyProof fail"
        );
        uint256 tokenId = box.heirToTokenid[heir];
        require(tokenId > 0, "PecuniaLock::withdraw: token id invalid");
        require(
            heirToken.getApproved(tokenId) == address(this),
            "Approval for NFT Token not given"
        );

        usedProof[proof[0]] = true;

        box.withdrawSigned[heir] = true;
        emit WithdrawSigned(box.user, heir, amount);
    }

    /**
     * @notice cancels the will and transfer all the assets back to owner and emits
     */
    function cancelBoxAndTransferFundsToOwner() external {
        address boxOwner = msg.sender;
        bytes32 boxhash = user2boxhash[boxOwner];

        require(
            boxhash != bytes32(0),
            "PecuniaLock::cancelBoxAndTransferFundsToOwner: safebox not register yet"
        );
        SafeBox storage box = boxhash2safebox[boxhash];
        require(
            msg.sender == box.user,
            "PecuniaLock::cancelBoxAndTransferFundsToOwner: only owner can cancel this"
        );
        require(
            block.timestamp > box.timeAtWhichPaymentStarts,
            "PecuniaLock::cancelBoxAndTransferFundsToOwner: cannot cancel time has passed"
        );
        address[] memory heirAddresses = box.addresss;

        // Transfer Matic
        uint256 totalDeposit = box.totalDeposit;
        if (totalDeposit > 0) {
            box.totalDeposit = 0; //prevent re-entracy
            safeTransferETH(boxOwner, totalDeposit);
        }

        //Transfer Nfts
        for (uint256 i = 0; i < heirAddresses.length; i++) {
            if (box.isActive[heirAddresses[i]]) {
                if (box.heirToNfts[heirAddresses[i]].length > 0) {
                    for (
                        uint256 j = 0;
                        j < box.heirToNfts[heirAddresses[i]].length;
                        j++
                    ) {
                        IERC721(box.nftAddress).safeTransferFrom(
                            address(this),
                            boxOwner,
                            box.heirToNfts[heirAddresses[i]][j]
                        );
                        console.log("Owner NFTs trasnffered back to owner");
                    }
                }
                box.isActive[heirAddresses[i]] = false;
            }
        }
        delete (boxhash2safebox[boxhash]);
        emit BoxCanceled(boxOwner);
    }

    function safeTransferETH(address to, uint256 value) internal {
        require(
            address(this).balance >= value,
            "PecuniaLock::safeTransferETH: Insufficient amount"
        );
        require(!locked, "PecuniaLock::safeTransferETH: Re-Entracy");
        locked = true;
        (bool success, ) = to.call{value: value}(new bytes(0));
        require(
            success,
            "TransferHelper::safeTransferETH: ETH transfer failed"
        );
        locked = false;
        emit FundsTransferred(value, to);
    }


    function withdrawAssets(address owner, address hr) external {
        bytes32 bh = user2boxhash[owner];

        if (
            (boxhash2safebox[bh].withdrawSigned[hr]) && //withdraw signature done
            (block.timestamp - boxhash2safebox[bh].timeAtWhichPaymentStarts >=
                boxhash2safebox[bh].heirToInterval) && // will has matured meaning timestamp has passed interval
            (block.timestamp - boxhash2safebox[bh].lastPaymentTime >=
                boxhash2safebox[bh].timeIntBetweenPayments) && // check if time diff b/w last payment and current time is greater than timeIntBetweenPayments
            boxhash2safebox[bh].isActive[hr] //check if will for the heir is active and not cancelled
        ) {
            // We first rateToSend which is amount of crypto transffered to heir at each interval.
            // This is equal to amount_deposited/number_of_payments
            uint256 rateToSend = boxhash2safebox[bh].ratePerHeir[hr];

            if (
                rateToSend > 0 &&
                // we are keeping a counter of number of payments done to heir and that should be less that number_of_paymets
                boxhash2safebox[bh].paymentsDoneToHeir <
                boxhash2safebox[bh].numberOfPayments
            ) {
                console.log("paying amt, to:", rateToSend, hr);
                //now we need to update two things for batch payments first is payments already done to heir and the second is
                // last timestamp when the payment was done to heir
                boxhash2safebox[bh].paymentsDoneToHeir++;
                boxhash2safebox[bh].lastPaymentTime = block.timestamp;
                safeTransferETH(hr, rateToSend);
            }
            if (boxhash2safebox[bh].nftAddress != address(0)) {
                for (
                    uint256 k = 0;
                    k < boxhash2safebox[bh].heirToNfts[hr].length;
                    k++
                ) {
                    IERC721(boxhash2safebox[bh].nftAddress).safeTransferFrom(
                        address(this),
                        hr,
                        boxhash2safebox[bh].heirToNfts[hr][k]
                    );
                    console.log("Owner NFT transffered");
                }
            }
            boxhash2safebox[bh].isActive[hr] = false;
            boxhash2safebox[bh].withdrawSigned[hr] = false;
            // TODO add else and gas optimization cond
        }
        if (gasleft() < MIN_GAS_FOR_TRANSFER) {
            return;
        }
    }

    function onERC721Received(
        address,
        address,
        uint256,
        bytes memory
    ) public virtual override returns (bytes4) {
        return this.onERC721Received.selector;
    }

    // Public Getter Setter Funcitons

    function getLastPaymentTime(address owner, address hr)
        public
        view
        returns (uint256)
    {
        return boxhash2safebox[user2boxhash[owner]].lastPaymentTime;
    }

    /**
     * @notice get heir amount from owner add
     * @param owner owner address
     * @param heir heir address
     * @return amount
     */
    function getHeirAmountFromOwner(address owner, address heir)
        public
        view
        returns (uint256)
    {
        return boxhash2safebox[user2boxhash[owner]].heirToBalance[heir];
    }

    /**
     * @notice get heir amount from box hash
     * @param boxhash boxhash
     * @param heir heir address
     * @return amount
     */
    function getHeirAmountFromOwner(bytes32 boxhash, address heir)
        public
        view
        returns (uint256)
    {
        return boxhash2safebox[boxhash].heirToBalance[heir];
    }

    /**
     * @notice get if heir has signed the will/box
     * @param owner owner address
     * @param heir heir address
     * @return bool
     */
    function getHeirWithdrawCounterFromOwner(address owner, address heir)
        public
        view
        returns (bool)
    {
        return boxhash2safebox[user2boxhash[owner]].withdrawSigned[heir];
    }

    /**
     * @notice get if heir has signed the will/box from boxhash
     * @param boxhash boxhash
     * @param heir heir address
     * @return bool
     */
    function getHeirWithdrawCounterFromBoxHash(bytes32 boxhash, address heir)
        public
        view
        returns (bool)
    {
        return boxhash2safebox[boxhash].withdrawSigned[heir];
    }

    /**
     * @notice get all the registered heirs array
     */
    function getSafeBoxHeirsFromOwner(address owner)
        public
        view
        returns (address[] memory)
    {
        return boxhash2safebox[user2boxhash[owner]].addresss;
    }

    /**
     * @notice get all the registered heirs array from box hash
     */
    function getSafeBoxHeirsFromBoxHash(bytes32 boxhash)
        public
        view
        returns (address[] memory)
    {
        return boxhash2safebox[boxhash].addresss;
    }

    /**
     * @notice get safe box details
     */
    function getSafeBoxDetailsFromOwner(address owner)
        public
        view
        returns (
            bytes32,
            uint256,
            uint256
        )
    {
        return (
            boxhash2safebox[user2boxhash[owner]].boxhash,
            boxhash2safebox[user2boxhash[owner]].heirToInterval,
            boxhash2safebox[user2boxhash[owner]].timeAtWhichPaymentStarts
        );
    }

    /**
     * @notice get safe box details from boxhash
     */
    function getSafeBoxDetailsFromBoxHash(bytes32 boxhash)
        public
        view
        returns (
            bytes32,
            uint256,
            uint256
        )
    {
        return (
            boxhash2safebox[boxhash].boxhash,
            boxhash2safebox[boxhash].heirToInterval,
            boxhash2safebox[boxhash].timeAtWhichPaymentStarts
        );
    }

    /**
     * @notice get time left for the will/box to expire/mature
     */
    function getTimeLeftFromOwner(address owner) public view returns (uint256) {
        return (block.timestamp -
            boxhash2safebox[user2boxhash[owner]].timeAtWhichPaymentStarts);
    }

    /**
     * @notice recieve funds
     */
    receive() external payable {
        emit FundsAdded(msg.value, address(this).balance, msg.sender);
    }
}
